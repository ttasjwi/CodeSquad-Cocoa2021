# Day 09

Date : 2021.11.11 (Thu)  
학습 내용 : 리뷰 및 수업

---

# 복습
 
## 자바 변수의 기본 타입들
- <a href="https://github.com/ttasjwi/CodeSquad-Cocoa2021/blob/master/Note/Variable/Variable_2.md" target="_blank">GitHub Repository</a>에 정리해둠

## 참조형

- 모든 참조형 : java.lang.Object의 자손
- cf) 메서드는 객체가 아니다.

## 객체
- java에서는 배열, 클래스의 인스턴스를 객체로 취급
- 참조형의 배열은 주솟값들의 배열

---

# 제어자 (modifier)
클래스, 변수, 또는 메서드의 선언부에 함께 사용되어 부가적인 의미를 부여함.
- 하나의 대상에 여러 제어자를 같이 사용할 수 있다. (단, 접근제어자는 한 개만!)
- 관례적으로 접근제어자-static-final-abstaract 순으로 사용.

## 1. 접근제어자 (access modifier)
멤버(멤버변수, 메서드, 생성자), 또는 클래스에 사용되어, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못 하도록 제한

1. public : 접근 제한이 전혀 없다.
2. protected : 같은 패키지 또는 같은 패키지에 위치한 자손 클래스에서 접근 가능
3. default : 같은 패키지 내에서만 접근 가능
    - 그냥 안 붙이면 된다.
4. private : 같은 클래스 내에서만 접근 가능

## 2. final : 마지막의, 변경될 수 없는
- 클래스 앞 : 확장될 수 없는 -> 다른 클래스의 조상이 될 수 없다.
- 메서드 앞 : 변경될 수 없는 -> 자손 클래스에서 오버라이딩을 통해 재정의할 수 없다.
- 멤버변수, 지역변수 : 한번 값이 저장되면 더 이상 변경할 수 없는 상수가 된다.

## 3. static : 클래스의, 공통적인
- 멤버변수 앞 -> static 변수화
  - 모든 인스턴스에 공통적으로 사용되는 클래스 변수
  - 인스턴스(객체)를 생성하지 않고도 사용할 수 있다.
  - 클래스가 클래스로더에 의해 static 영역에 생성될 때 생성된다.
- 메서드 앞
  - 인스턴스(객체)를 생성하지 않고도 호출 가능한 static 메서드가 된다.
  - static 메서드 내에서는 인스턴스 멤버를 직접 사용할 수 없다.  

  ### (cf) static final : 변경될 수 없는 + 공통적인
  - 멤버변수 앞 : static 상수화
    - 모든 인스턴스에서 공통적으로 사용될 수 있는 상수 (변경될 수 없는 변수)
    - 인스턴스(객체)를 생성하지 않고도 사용할 수 있다.
  - 메서드 앞 : 자손 클래스에서 오버라이딩을 통해 재정의 할 수 없는 static 메서드

## 4. abstract : 추상의, 미완성의
- 추상 메서드를 선언할 때 사용
- 클래스 선언시 사용하면 이 클래스가 추상클래스임을 알림.


# 캡슐화와 접근제어자
- 접근 제어자를 사용하는 이유
  1. 외부로부터 데이터를 보호하기 위해 (외부에서 메서드를 통해 간접 접근 허용)
  2. 외부에는 불필요한, 내부적으로만 사용되는 부분을 은닉하기 위해.
- 멤버변수를 아무리 private로 해놓더라도... 
  - getter, setter를 안 쓰는 방향을 생각해봐야함. (데이터 보호, 은닉의 취지와 약간 벗어나게 됨)

---

## 함수/메서드
- Argument(인자, 인수) : 메서드 호출 시 괄호 안에 지정해준 값
- Parameter(매개변수) : 메서드 선언 시 괄호 안에 지정해준 값. Argument가 복제되어 Parameter에 대입된다.

이하는 Day07 문서 작성된 것에서 그대로 복붙했다.
- Java에서는 Call by Value만 존재한다.
    - 기본형 : argument를 복제하여 Parameter에 대입함. 따라서 argument에 영향을 미치지 않는다.
    - 참조형 : argument의 value가 객체의 주소참조값이다. parameter에 주소참조값을 복사하여 넘김. argument를 복사하여 전달한다는 점에서는 Call by Value의 원칙은 그대로. 하지만, Heap에 위치한 객체의 주소참조값을 넘기므로, 작업 과정에서 객체 그 자체에 영향을 미친다.
- return 명령어가 가지는 두 가지 의미
    - 호출한 위치로 돌아간다.
    - 반환값이 있는 경우, 호출한 위치에 값을 반환한다.
- return을 사용해야 하는 이유
    - 메서드의 역할수행을 끝마치고 종료하기 위해
    - 호출한 측에 결과값을 반환하기 위해

---

## 클래스
Day 07에 이미 정리해놔서 그대로 복붙했다.

- 클래스 : 객체를 정의한 것. (상태 : 멤버변수, 행동 : 메서드)
- 객체 : 클래스에 정의된 것을 바탕으로 만들어진, 실제로 존재하는 것.
- 객체 vs 인스턴스 : 거의 구분할 필요는 없음.
    - 객체 : 모든 인스턴스를 대표하는 포괄적 의미
    - 인스턴스 : 어떤 클래스로부터 만들어진 것인지를 보다 강조하는 의미

- 멤버변수(static 변수, 인스턴스변수) 및 지역변수
  - 선언위치에 따른 변수의 종류 부분 : <a href="https://github.com/ttasjwi/CodeSquad-Cocoa2021/blob/master/Note/Variable/Variable_1.md" target="_blank">GitHub Repository</a>에 정리해둠

---

# 클래스의 상속

## 1. 상속이란?
- 기존 클래스를 재사용하거나, 기능을 확장하여 새로운 클래스를 작성하는 것. (코드의 재사용)
- 두 클래스를 조상과 자손으로 관계를 맺어주는 행위
- 자손은 조상의 멤버를 상속받는다. (단, 생성자 및 초기화 블럭 제외)
- 조상으로부터 상속받은 멤버의 변경은 조상 클래스의 멤버에 영향을 미치지 않는다.
- 자손 클래스에서 새로 정의한 멤버는 조상 클래스에서 사용할 수 없다.


## 2. 상속 vs 포함관계
- 포함관계 : 클래스의 멤버로 다른 클래스 타입의 참조변수를 선언하는 것.
- 작은 단위의 클래스를 정의하고, 이들을 구성요소로 한 클래스를 정의할 수 있다.

## 3. 단일 상속
- Java는 단일 상속(하나의 부모만 상속)만 허용.

## 4. Object 클래스
- 모든 클래스는 Object 클래스의 자손이다. 조상이 없는 클래스는 자동으로 Object 클래스를 상속 받음.
- 모든 클래스는 Object 클래스에 정의된 11개의 메서드를 상속받는다.
  - equals, hashCode, toString, ...

---

# 메서드 오버라이딩
- 상속받은 조상의 메서드를 자신에 맞게 변경하는 것
- 필수는 아니지만 오버라이딩 한 메서드에 @Override 애너테이션을 달아주자!

## 1. 오버라이딩의 조건 (규칙)  
1. 선언부가 조상과 일치
2. 접근제어자(access modifier)를 조상보다 좁은 범위로 변경할 수 없음!
3. 예외(Exception)는 조상 메서드보다 더 많이 선언할 수 없음.

## 2. 오버라이딩 vs 오버로딩
1. 오버라이딩(자손측에서 재정의) : 상속받은 메서드의 내용을 변경하는 것. 가져다 덮어씀.
2. 오버로딩(다중 정의) : 같은 이름의 메서드를 여러방식으로 정의

## 3. 참조변수 super
- 인스턴스 메서드(또는 생성자)에서, 조상 객체를 가리키는 참조변수
- 인스턴스 메서드(또는 생성자) 내에서만 사용 가능
- 조상의 멤버(멤버변수, 멤버 메서드)와 자손의 멤버(멤버변수, 멤버 메서드)명이 서로 같을 때 구분하기 위해 사용
    ```
    class Parent {
        protected int x = 10;
    }
    
    class Child extends Parent {
        protected int x = 20;
        
        public void method() {
            System.out.println("x="+x); // 인스턴스 자신의 멤버변수 x가 호출됨 (아래의 코드와 구조적 동일) -> 10 출력
            System.out.println("this.x="+this.x); // 인스턴스 자신의 멤버변수 x가 호출됨. => 10 출력
            System.out.println("super.x="+super.x); // 인스턴스 자신의 조상에게 상속받은 멤버변수 super.x가 호출됨. -> 20 출력
        }
    }
    ```

### 4. 참조변수 super()
- 조상의 생성자를 호출할 때 사용(생성자와 초기화 블럭은 상속되지 않으므로)
- 조상의 멤버는 조상의 생성자를 호출해서 초기화할 수 있다.
- 자손의 생성자는 자손 자신이 선언한 변수만 초기화할 수 있다.

**<주의점!!!>**
- 생성자의 **첫 줄**에 조상의 생성자를 수동으로 호출하는 것이 좋다. 존재성을 잊지 말자.
- 조상의 생성자를 호출하지 않을 경우, 컴파일러가 자동으로 생성자 첫줄에 super()을 삽입함. (모든 클래스의 최상위 조상은 Object이므로 직접 상속받은 객체가 없더라도 추가됨)
- 만약 조상측에 기본 생성자가 존재하지 않을 경우 다음 방식으로 코드를 수정해야한다. 수정하지 않을 경우 컴파일 에러가 발생함.
  - 조상 클래스에 기본 생성자를 추가하거나,
  - 자손측 생성자에 수동으로 super(Argument ...a)를 호출하거나.


---

## 자바 컬렉션 라이브러리

1. 왜 필요한가?
    - 다량의 데이터들을 저장하여 표준화된 방법으로 다루기 위함.
2. 가장 많이 사용되는 컬렉션 라이브러리는?
   - List (대부분)
   - Map
3. 컬렉션별 용도들
   1. List : 저장 순서 존재, 중복을 허용한다.
   2. Set : 저장 순서 존재 x, 중복을 허용하지 않는다.
   3. Map : 저장 순서 존재 x, (Key, Value) 쌍으로 자료를 저장하며, Key의 중복을 허용하지 않는다.
4. List, Map, Set

---

## 컬렉션을 이용한 객체의 정렬
### 1. 객체에 인터페이스 Comparable<T>을 구현하여 정렬하는 방법
- 어떤 객체의 기본 정렬 기준을 구현하는데 사용
- java.lang 패키지에 존재하기 때문에 별도의 import 필요 없음.
- public int compareTo(T t) 을 완성하면 됨
  - 반환값 음수 : 작은 겂이 앞에 정렬됨.
  - 반환값 0 : 정렬 순위가 같다.
  - 반환값 양수 : 뒤에 정렬됨.
  - jdk 라이브러리에 포함된 대다수의 클래스들은 Comparable이 구현되어 있다.
    - 예) 래퍼클래스(Integer, Double, ...) , String, LocalDate, LocalTime, ...
### 2. 인터페이스 Comparator<T> 의 구현체를 통한 정렬
- 별도의 정렬기준을 구현하는데 사용.
- import java.util.Comparator;
- public int compare(T t1, T t2) 을 완성하면 됨.
  - 반환값이 음수 : 작은 값이 앞에 정렬됨
  - 반환값이 0 : 정렬 순위가 같다.
  - 반환값이 양수 : 뒤에 정렬됨.
### 3. List의 sort()메서드, Arrays.sort(), Collections.sort() 메서드
- 지정 배열, 컬렉션을 정렬함.
- List의 sort()
  - default void sort(Comparator<? super E> c) : List인터페이스의 디폴트 메서드. 1.8부터 사용 가능.
- Arrays.sort()
    - public static void sort(Object[] a) : Comparable 구현에 의한 정렬
    - public static <T> void sort(T[] a, Comparator<? super T> c) : Comparator 구현에 의한 정렬
- Collections.sort()
  - public static <T extends Comparable<? super T>> void sort(List<T> list) : Comparable 구현에 의한 정렬
  - public static <T> void sort(List<T> list, Comparator<? super T> c) : Comparator 구현에 의한 정렬


### 4. TreeSet, TreeMap
- 이진 탐색 트리(binary search tree) 자료구조의 형태로 데이터를 저장
- 생성 시, Comparator를 인자로 하여 정렬기준을 지정할 수 있음.
- 별도로 정렬기준을 지정하지 않았을 경우, Comparable 구현에 의한 정렬

### 5. Stream의 sorted() 메서드를 이용한 정렬
  - 배열을 정렬할 때는 Arrays.sort, 컬렉션을 정렬할 때는 Collections.sort()를 사용해야하는 등 각 저장방식에 따라 정렬 방식이 표준화되어 있지 않음.
  - Stream을 이용하여 표준화된 방식으로 데이터를 다룰 수 있음.
  - Stream<T> sorted() : Comparable 구현에 의한 정렬
  - Stream<T> sorted(Comparator<? super T> comparator) : Comparator 구현에 의한 정렬
    - Comparator 대신 int값을 반환하는 람다식을 사용하는 것도 가능


--- 

## 리뷰 및 피드백
- 배웠던 것들이 많지만, 다시 공부해보니 생소한 것들도 많다. 자주자주 확인하면서 복습하자.

## 더 공부할 주제들
- 자바 제네릭
- 자바 람다 문법
- 람다의 활용 (Stream?)
